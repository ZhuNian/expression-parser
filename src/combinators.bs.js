// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Utils$ExpressionParserDemo = require("./utils.bs.js");

function run(p, input) {
  return Curry._1(p[0], input);
}

function bind(p, f) {
  var innerFn = function (input) {
    var match = run(p, input);
    if (match.tag) {
      return /* Error */Block.__(1, [match[0]]);
    } else {
      var match$1 = match[0];
      return run(Curry._1(f, match$1[0]), match$1[1]);
    }
  };
  return /* Parser */[innerFn];
}

function andThen(p1, p2) {
  var innerFn = function (input) {
    return Utils$ExpressionParserDemo.$neg$neg$great(run(p1, input), (function (param) {
                  var current1 = param[0];
                  return Utils$ExpressionParserDemo.$neg$neg$great(run(p2, param[1]), (function (param) {
                                return /* Ok */Block.__(0, [/* tuple */[
                                            /* tuple */[
                                              current1,
                                              param[0]
                                            ],
                                            param[1]
                                          ]]);
                              }));
                }));
  };
  return /* Parser */[innerFn];
}

function orElse(p1, p2) {
  var innerFn = function (input) {
    var match = run(p1, input);
    if (match.tag) {
      return run(p2, input);
    } else {
      return /* Ok */Block.__(0, [match[0]]);
    }
  };
  return /* Parser */[innerFn];
}

function map(p, mapFunc) {
  var innerFn = function (input) {
    var match = run(p, input);
    if (match.tag) {
      return /* Error */Block.__(1, [match[0]]);
    } else {
      var match$1 = match[0];
      return /* Ok */Block.__(0, [/* tuple */[
                  Curry._1(mapFunc, match$1[0]),
                  match$1[1]
                ]]);
    }
  };
  return /* Parser */[innerFn];
}

function returnP(res) {
  var innerFn = function (input) {
    return /* Ok */Block.__(0, [/* tuple */[
                res,
                input
              ]]);
  };
  return /* Parser */[innerFn];
}

function applyP(p1, p2) {
  return bind(p1, (function (param) {
                return map(p2, param);
              }));
}

function lift2(fn, p1, p2) {
  var p1$1 = returnP(fn);
  var p1$2 = bind(p1$1, (function (param) {
          return map(p1, param);
        }));
  return bind(p1$2, (function (param) {
                return map(p2, param);
              }));
}

function anyOf(l) {
  return l.slice(1, l.length).reduce(orElse, Caml_array.caml_array_get(l, 0));
}

var $eq$eq$great = bind;

var $unknown$great = andThen;

var $unknown$pipe = orElse;

var $unknown$eq = map;

var $less$star$great = applyP;

exports.run = run;
exports.bind = bind;
exports.$eq$eq$great = $eq$eq$great;
exports.andThen = andThen;
exports.$unknown$great = $unknown$great;
exports.orElse = orElse;
exports.$unknown$pipe = $unknown$pipe;
exports.map = map;
exports.$unknown$eq = $unknown$eq;
exports.returnP = returnP;
exports.applyP = applyP;
exports.$less$star$great = $less$star$great;
exports.lift2 = lift2;
exports.anyOf = anyOf;
/* No side effect */
