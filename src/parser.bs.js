// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Evaluate$ExpressionParserDemo = require("./evaluate.bs.js");

function $at$pipe(p1, p2, input) {
  var match = Curry._1(p1, input);
  if (match.tag) {
    return Curry._1(p2, input);
  } else {
    return /* Ok */Block.__(0, [
              match[0],
              match[1]
            ]);
  }
}

function $at$less$less(onOk, onError, res) {
  if (res.tag) {
    return Curry._1(onError, res[0]);
  } else {
    return Curry._2(onOk, res[0], res[1]);
  }
}

function isChar(isChar_, input) {
  var c = input.charAt(0);
  if (Curry._1(isChar_, c)) {
    return /* Ok */Block.__(0, [
              c,
              input.slice(1, input.length)
            ]);
  } else {
    return /* Error */Block.__(1, [input]);
  }
}

function isDigitalChar(param) {
  return isChar((function (c) {
                return "0123456789".includes(c);
              }), param);
}

function isAddChar(param) {
  return isChar((function (c) {
                return c === "+";
              }), param);
}

function isMinusChar(param) {
  return isChar((function (c) {
                return c === "-";
              }), param);
}

function isEmptyChar(param) {
  return isChar((function (c) {
                return c === "";
              }), param);
}

function digitalParser_(input) {
  return $at$less$less((function (c, remain) {
                return /* Ok */Block.__(0, [
                          /* Digital */Block.__(0, [c]),
                          remain
                        ]);
              }), (function (err) {
                return /* Error */Block.__(1, [err]);
              }), isDigitalChar(input));
}

function emptyParser(input) {
  return $at$less$less((function (param, param$1) {
                return /* Ok */Block.__(0, [
                          "",
                          input
                        ]);
              }), (function (param) {
                return /* Error */Block.__(1, [input]);
              }), isEmptyChar(input));
}

function many(res, pChar, input) {
  return $at$less$less((function (param, param$1) {
                return /* Error */Block.__(1, [input]);
              }), (function (e) {
                return $at$less$less((function (char_, remain) {
                              return $at$less$less((function (param, param$1) {
                                            return /* Ok */Block.__(0, [
                                                      res + char_,
                                                      ""
                                                    ]);
                                          }), (function (param) {
                                            return many(res + char_, pChar, remain);
                                          }), emptyParser(remain));
                            }), (function (err) {
                              return /* Ok */Block.__(0, [
                                        res,
                                        err
                                      ]);
                            }), Curry._1(pChar, e));
              }), emptyParser(input));
}

function digitalParser(input) {
  return $at$less$less((function (d, remain) {
                return $at$less$less((function (param, param$1) {
                              return /* Error */Block.__(1, [input]);
                            }), (function (param) {
                              return /* Ok */Block.__(0, [
                                        /* Digital */Block.__(0, [d]),
                                        remain
                                      ]);
                            }), emptyParser(d));
              }), (function (param) {
                return /* Error */Block.__(1, [input]);
              }), many("", isDigitalChar, input));
}

function parserGenerator(opSplitter, onOk, exp1, input) {
  return $at$less$less((function (param, opRemain) {
                return $at$less$less((function (exp2, remain2) {
                              return /* Ok */Block.__(0, [
                                        Curry._2(onOk, exp1, exp2),
                                        remain2
                                      ]);
                            }), (function (err) {
                              return /* Error */Block.__(1, [err]);
                            }), digitalParser(opRemain));
              }), (function (err) {
                return /* Error */Block.__(1, [err]);
              }), Curry._1(opSplitter, input));
}

function addParser(param, param$1) {
  return parserGenerator(isAddChar, (function (exp1, exp2) {
                return /* Add */Block.__(1, [
                          exp1,
                          exp2
                        ]);
              }), param, param$1);
}

function minusParser(param, param$1) {
  return parserGenerator(isMinusChar, (function (exp1, exp2) {
                return /* Minus */Block.__(2, [
                          exp1,
                          exp2
                        ]);
              }), param, param$1);
}

function parser_(exp, input) {
  var expressionParser = function (param) {
    return $at$pipe((function (param) {
                  return addParser(exp, param);
                }), (function (param) {
                  return minusParser(exp, param);
                }), param);
  };
  return $at$less$less((function (param, param$1) {
                return /* Ok */Block.__(0, [
                          exp,
                          input
                        ]);
              }), (function (input_) {
                return $at$less$less(parser_, (function (err) {
                              return /* Error */Block.__(1, [err]);
                            }), expressionParser(input_));
              }), emptyParser(input));
}

function negativeDigitalParser(input) {
  return $at$less$less((function (param, remain) {
                return $at$less$less((function (d, remain2) {
                              return /* Ok */Block.__(0, [
                                        /* Minus */Block.__(2, [
                                            /* Digital */Block.__(0, ["0"]),
                                            d
                                          ]),
                                        remain2
                                      ]);
                            }), (function (param) {
                              return /* Error */Block.__(1, [input]);
                            }), digitalParser(remain));
              }), (function (param) {
                return digitalParser(input);
              }), isMinusChar(input));
}

function parser(input) {
  return $at$less$less((function (exp, param) {
                return String(Evaluate$ExpressionParserDemo.evaluate(exp));
              }), (function (param) {
                return "failed: " + input;
              }), $at$less$less(parser_, (function (param) {
                    return /* Error */Block.__(1, [input]);
                  }), $at$less$less((function (param, param$1) {
                        return /* Error */Block.__(1, [input]);
                      }), negativeDigitalParser, emptyParser(input))));
}

function logParse(input) {
  console.log(parser(input));
  return /* () */0;
}

console.log(parser("1e23e"));

console.log(parser("123+1"));

exports.$at$pipe = $at$pipe;
exports.$at$less$less = $at$less$less;
exports.isChar = isChar;
exports.isDigitalChar = isDigitalChar;
exports.isAddChar = isAddChar;
exports.isMinusChar = isMinusChar;
exports.isEmptyChar = isEmptyChar;
exports.digitalParser_ = digitalParser_;
exports.emptyParser = emptyParser;
exports.many = many;
exports.digitalParser = digitalParser;
exports.parserGenerator = parserGenerator;
exports.addParser = addParser;
exports.minusParser = minusParser;
exports.parser_ = parser_;
exports.negativeDigitalParser = negativeDigitalParser;
exports.parser = parser;
exports.logParse = logParse;
/*  Not a pure module */
